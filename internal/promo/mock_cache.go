// Code generated by MockGen. DO NOT EDIT.
// Source: cache.go

// Package promo is a generated GoMock package.
package promo

import (
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
)

// MockCache is a mock of Cache interface.
type MockCache struct {
	ctrl     *gomock.Controller
	recorder *MockCacheMockRecorder
}

// MockCacheMockRecorder is the mock recorder for MockCache.
type MockCacheMockRecorder struct {
	mock *MockCache
}

// NewMockCache creates a new mock instance.
func NewMockCache(ctrl *gomock.Controller) *MockCache {
	mock := &MockCache{ctrl: ctrl}
	mock.recorder = &MockCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCache) EXPECT() *MockCacheMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockCache) Get(code string) (Coupon, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", code)
	ret0, _ := ret[0].(Coupon)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCacheMockRecorder) Get(code interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCache)(nil).Get), code)
}

// IncrementLoaded mocks base method.
func (m *MockCache) IncrementLoaded() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "IncrementLoaded")
}

// IncrementLoaded indicates an expected call of IncrementLoaded.
func (mr *MockCacheMockRecorder) IncrementLoaded() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IncrementLoaded", reflect.TypeOf((*MockCache)(nil).IncrementLoaded))
}

// IsReady mocks base method.
func (m *MockCache) IsReady() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsReady")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsReady indicates an expected call of IsReady.
func (mr *MockCacheMockRecorder) IsReady() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsReady", reflect.TypeOf((*MockCache)(nil).IsReady))
}

// LoadedSuccessfully mocks base method.
func (m *MockCache) LoadedSuccessfully() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadedSuccessfully")
	ret0, _ := ret[0].(bool)
	return ret0
}

// LoadedSuccessfully indicates an expected call of LoadedSuccessfully.
func (mr *MockCacheMockRecorder) LoadedSuccessfully() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadedSuccessfully", reflect.TypeOf((*MockCache)(nil).LoadedSuccessfully))
}

// MarkLoadedSuccessfully mocks base method.
func (m *MockCache) MarkLoadedSuccessfully() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "MarkLoadedSuccessfully")
}

// MarkLoadedSuccessfully indicates an expected call of MarkLoadedSuccessfully.
func (mr *MockCacheMockRecorder) MarkLoadedSuccessfully() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkLoadedSuccessfully", reflect.TypeOf((*MockCache)(nil).MarkLoadedSuccessfully))
}

// MarkReady mocks base method.
func (m *MockCache) MarkReady() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "MarkReady")
}

// MarkReady indicates an expected call of MarkReady.
func (mr *MockCacheMockRecorder) MarkReady() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkReady", reflect.TypeOf((*MockCache)(nil).MarkReady))
}

// Progress mocks base method.
func (m *MockCache) Progress() float64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Progress")
	ret0, _ := ret[0].(float64)
	return ret0
}

// Progress indicates an expected call of Progress.
func (mr *MockCacheMockRecorder) Progress() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Progress", reflect.TypeOf((*MockCache)(nil).Progress))
}

// Set mocks base method.
func (m *MockCache) Set(code string, cp Coupon) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Set", code, cp)
}

// Set indicates an expected call of Set.
func (mr *MockCacheMockRecorder) Set(code, cp interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCache)(nil).Set), code, cp)
}

// SetTotalFiles mocks base method.
func (m *MockCache) SetTotalFiles(n int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetTotalFiles", n)
}

// SetTotalFiles indicates an expected call of SetTotalFiles.
func (mr *MockCacheMockRecorder) SetTotalFiles(n interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTotalFiles", reflect.TypeOf((*MockCache)(nil).SetTotalFiles), n)
}

// WaitUntilReady mocks base method.
func (m *MockCache) WaitUntilReady(timeout time.Duration) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitUntilReady", timeout)
	ret0, _ := ret[0].(bool)
	return ret0
}

// WaitUntilReady indicates an expected call of WaitUntilReady.
func (mr *MockCacheMockRecorder) WaitUntilReady(timeout interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitUntilReady", reflect.TypeOf((*MockCache)(nil).WaitUntilReady), timeout)
}
